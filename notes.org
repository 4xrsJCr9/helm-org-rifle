* Code

These come in handy while coding.

** Profiling

Why aren't macros like these in some default package?  Sure beats having to type ~(mapcar (lambda (it) (...it...)) list)~ over and over.

#+BEGIN_SRC elisp
  (defmacro it (&rest body)
    `(lambda (it)
       ,@body))
  (defmacro mapit (seq &rest body)
    `(mapcar (lambda (it)
               ,@body)
             ,seq))
#+END_SRC

This makes it easy to profile code:

#+BEGIN_SRC elisp
  (defmacro profile-rifle (times &rest body)
    `(let (output)
       (dolist (p '("helm-" "org-" "string-" "s-" "buffer-" "append" "delq" "map" "list" "car" "save-" "outline-" "delete-dups" "sort" "line-" "nth" "concat" "char-to-string" "rx-" "goto-" "when" "search-" "re-"))
         (elp-instrument-package p))
       (dotimes (x ,times)
         ,@body)
       (elp-results)
       (elp-restore-all)
       (point-min)
       (forward-line 20)
       (delete-region (point) (point-max))
       (setq output (buffer-substring-no-properties (point-min) (point-max)))
       (kill-buffer)
       (delete-window)
       output))
#+END_SRC

#+RESULTS:
: profile-rifle

** Open Helm session on current org buffers

#+BEGIN_SRC elisp
(let ((helm-candidate-separator " "))
  (helm :sources (helm-org-rifle-get-sources)))

(let ((helm-candidate-separator " ")
      (helm-org-rifle-show-path t))
  (helm :sources (helm-org-rifle-get-sources)))
#+END_SRC

*** Without fontification

#+BEGIN_SRC elisp
(let ((helm-candidate-separator " ")
      (helm-org-rifle-fontify-headings nil))
  (helm :sources (helm-org-rifle-get-sources)))

(let ((helm-candidate-separator " ")
      (helm-org-rifle-show-path t)
      (helm-org-rifle-fontify-headings nil))
  (helm :sources (helm-org-rifle-get-sources)))
#+END_SRC

** Get list of candidates for "test.org" buffer

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "pomegr blueberry")
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "green")
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "green blue")
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "pomegr")

(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "helm food")

(let ((helm-candidate-separator " ")
      (helm-org-rifle-show-path t))
  (helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "green blue"))
#+END_SRC

*** Other buffers

#+BEGIN_SRC elisp
(let ((helm-org-rifle-fontify-headings nil))
  (helm-org-rifle-get-candidates-in-buffer (get-buffer "reference.org") "emacs"))

(helm-org-rifle-get-candidates-in-buffer (get-buffer "reference.org") "emacs")
(helm-org-rifle-get-candidates-in-buffer (get-buffer "main.org") "emacs")

(helm-org-rifle-get-candidates-in-buffer (get-buffer "main.org") "tires")

#+END_SRC

** Context-splitting

Prototype code, keeping for future reference.

#+BEGIN_SRC elisp
(let* ((num-context-words 2)
       (needle "needle")
       (haystack "one two three needle four five six")
       (hay (s-split needle haystack))
       (left-hay (s-split-words (car hay)))
       (right-hay (s-split-words (nth 1 hay))))
  (concat "..."
          (s-join " " (subseq left-hay (- num-context-words)))
          " " needle " "
          (s-join " " (subseq right-hay 0 num-context-words))
          "..."))

;; Multiple needles
(let* ( (needles '("needle" "pin"))
        (haystack "one two three \" needle not pin four five six seven eight pin nine ten eleven twelve"))
  (cl-loop for needle in needles
           append (cl-loop for re = (rx-to-string `(and (repeat 1 ,helm-org-rifle-context-words (and (1+ (not space))
                                                                                                     (or (1+ space)
                                                                                                         word-boundary)))
                                                        (group (eval needle))
                                                        (repeat 1 ,helm-org-rifle-context-words (and (or word-boundary
                                                                                                         (1+ space))
                                                                                                     (1+ (not space))))))
                           for m = (string-match re haystack end)
                           for end = (match-end 1)
                           while m
                           collect (concat "..." (match-string-no-properties 0 haystack) "..."))))
#+END_SRC

*** Slow code that splits on word boundaries

This code splits on word boundaries, but it's very slow.  Profiling it
showed the vast majority of the time was in =string-match=.  I'm
guessing the regexp is too complicated or unoptimized.

#+BEGIN_SRC elisp
  ;; Reduce matching lines to matched word with context
  (setq matched-words-with-context
        (cl-loop for line in (map 'list 'car matching-lines-in-node)
                 append (cl-loop for token in input
                                 for re = (rx-to-string
                                           `(and (repeat 0 ,helm-org-rifle-context-words
                                                         (and (1+ (not space))
                                                              (or (1+ space)
                                                                  word-boundary)))
                                                 (group (eval token))
                                                 (repeat 0 ,helm-org-rifle-context-words
                                                         (and (or word-boundary
                                                                  (1+ space))
                                                              (1+ (not space))))))
  
                                 ;;  This one line uses about 95% of the runtime of this function
                                 for m = (string-match re line end)
  
                                 for end = (match-end 1)
                                 when m
                                 collect (match-string-no-properties 0 line))))
#+END_SRC

*** Faster version that cuts off mid-word

This version is much, much faster, but instead of matching on word
boundaries, it just matches so-many characters before and after the
token.  It's not quite as nice, but the speedup is worth it, and it
seems good enough.

This is the version currently in-use.

#+BEGIN_SRC elisp
(setq matched-words-with-context
                    (cl-loop for line in (map 'list 'car matching-lines-in-node)
                             append (cl-loop for token in input
                                             for re = (rx-to-string '(and (repeat 0 25 not-newline)
                                                                          (eval token)
                                                                          (repeat 0 25 not-newline)))
                                             for m = (string-match re line end)

                                             for end = (match-end 1)
                                             when m
                                             collect (match-string-no-properties 0 line))))
#+END_SRC

*** DONE Fix it
CLOSED: [2016-04-01 Fri 22:55]
:LOGBOOK:
- State "DONE"       from "TODO"       [2016-04-01 Fri 22:55] \\
  Okay, it works now.  Here's hoping I don't break it again.
- State "TODO"       from "TODO"       [2016-04-01 Fri 19:03]
:END:

[2016-04-01 Fri 19:03] Somehow I broke it.  Now to fix it...

I don't understand why this loop isn't working like I want it to:

#+BEGIN_SRC elisp
  (cl-loop with end
           for line in (mapcar 'car matching-lines-in-node)
           for token in input
           for re = (rx-to-string `(and (repeat 0 ,helm-org-rifle-context-characters not-newline)
                                        (eval token)
                                        (repeat 0 ,helm-org-rifle-context-characters not-newline)))
           for match = (string-match re line end)
           for end = (match-end 0)
           when match
           collect (match-string-no-properties 0 line))
#+END_SRC

From what I can tell from the manual, it should do what I want.  Let's try this:

#+BEGIN_SRC elisp
  (cl-loop for line in '("1" "2" "3")
           for word in '("a" "b" "c")
           collect (list (format "Line:%s Word:%s" line word)))
#+END_SRC

#+RESULTS:
| Line:1 Word:a |
| Line:2 Word:b |
| Line:3 Word:c |

Well that does /not/ behave like Python list-comps.  So let's try nested:

#+BEGIN_SRC elisp
  (cl-loop for line in '("1" "2" "3")
           collect (cl-loop for word in '("a" "b" "c")
                            collect (format "Line:%s Word:%s" line word)))
#+END_SRC

#+RESULTS:
| Line:1 Word:a | Line:1 Word:b | Line:1 Word:c |
| Line:2 Word:a | Line:2 Word:b | Line:2 Word:c |
| Line:3 Word:a | Line:3 Word:b | Line:3 Word:c |

There.  So this loop should work:

#+BEGIN_SRC elisp
  (cl-loop with end
           for line in (mapcar 'car matching-lines-in-node)
for end = nil
           collect (cl-loop for token in input
                            for re = (rx-to-string `(and (repeat 0 ,helm-org-rifle-context-characters not-newline)
                                                         (eval token)
                                                         (repeat 0 ,helm-org-rifle-context-characters not-newline)))
                            for match = (string-match re line end)
                            for end = (match-end 0)
                            when match
                            collect (match-string-no-properties 0 line)))
#+END_SRC

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "~/org/inbox.org") "emacs :org:")
#+END_SRC

Hm...not quite.  Well, this is the code from just before the commit that broke it:

#+BEGIN_SRC elisp
  (setq matched-words-with-context
        (cl-loop for line in (map 'list 'car matching-lines-in-node)
                 append (cl-loop with end
                                 for token in input
                                 for re = (rx-to-string `(and (repeat 0 ,helm-org-rifle-context-characters not-newline)
                                                              (eval token)
                                                              (repeat 0 ,helm-org-rifle-context-characters not-newline)))
                                 for match = (string-match re line end)
                                 if match
                                 do (setq end (match-end 0))
                                 and collect (match-string-no-properties 0 line)
  
#+END_SRC

**** Profile with fix

#+BEGIN_SRC elisp 
(profile-rifle 10 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm !mail"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       10          5.8943273229  0.5894327322
search-forward-regexp                                         8600        0.6587784959  7.660...e-05
org-heading-components                                        1950        0.4991581810  0.0002559785
s-matches?                                                    12470       0.2917804840  2.339...e-05
mapconcat                                                     3960        0.2702167040  6.823...e-05
helm-org-rifle-fontify-like-in-org-mode                       190         0.2635406889  0.0013870562
goto-char                                                     8610        0.2543786740  2.954...e-05
rx-form                                                       9980        0.2420250770  2.425...e-05
org-back-to-heading                                           1950        0.2031512759  0.0001041801
outline-back-to-heading                                       1950        0.1968846809  0.0001009665
s-join                                                        2520        0.1756191310  6.969...e-05
string-match                                                  15810       0.1671791649  1.057...e-05
org-do-latex-and-related                                      190         0.1668239079  0.0008780205
org-string-nw-p                                               190         0.1662417530  0.0008749565
outline-next-heading                                          1960        0.1556081469  7.939...e-05
line-beginning-position                                       9630        0.1470939420  1.527...e-05
line-end-position                                             4720        0.1437326400  3.045...e-05
rx-to-string                                                  1430        0.1409834220  9.858...e-05
rx-and                                                        1430        0.1234839939  8.635...e-05
outline-previous-heading                                      1950        0.0872664470  4.475...e-05
#+end_example

Hm, that seems nearly twice as slow as before, compared to [[id:413c432f-6c8a-4f41-bbd4-486d859fe571][this]].  Let's try without negation:

#+BEGIN_SRC elisp 
(profile-rifle 10 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       10          6.000442529   0.6000442529
rx-form                                                       9940        0.7762075249  7.808...e-05
search-forward-regexp                                         6740        0.6341296550  9.408...e-05
org-heading-components                                        1950        0.5162909810  0.0002647646
rx-to-string                                                  1420        0.4960243830  0.0003493129
rx-and                                                        1420        0.3026813919  0.0002131559
mapconcat                                                     3950        0.2855619800  7.229...e-05
goto-char                                                     8700        0.2558434080  2.940...e-05
org-back-to-heading                                           1950        0.2032723169  0.0001042422
outline-back-to-heading                                       1950        0.1968941550  0.0001009713
car                                                           27602       0.1839865229  6.665...e-06
string-match                                                  15930       0.1689102720  1.060...e-05
outline-next-heading                                          1960        0.1560765069  7.963...e-05
line-beginning-position                                       9770        0.1480645649  1.515...e-05
line-end-position                                             4790        0.1447068689  3.021...e-05
s-matches?                                                    12640       0.1309880819  1.036...e-05
helm-org-rifle-fontify-like-in-org-mode                       190         0.1011150069  0.0005321842
outline-previous-heading                                      1950        0.0869701169  4.460...e-05
rx-repeat                                                     2840        0.0425908090  1.499...e-05
buffer-substring-no-properties                                8940        0.0324401760  3.628...e-06
#+end_example

Okay, that's bad.  But something is obviously wrong, because it's calling =rx-form= and =search-forward-regexp= way too many times.  Let's see...

The problem is that the =positive-re= is matching anywhere, not just at word boundaries, so it's matching way too many nodes.  Well, that is /a/ problem; I don't know if it explains the entire slowdown.

For example, this matches =overwhelming= because of the =helm= in the middle:

#+BEGIN_SRC elisp
"\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\)emacs\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\|$\\)\\|\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\)helm\\(\\(?:[ 	]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?\\| \\|$\\)"
#+END_SRC

Okay, the problem now is that I changed =helm-org-rifle-tags-re= to fix tag matching, but that same regexp is used in =helm-org-rifle-prep-token=, and now that function is matching any token as a tag and giving the wrong result.

I do not understand /why/ it's doing that, because that regexp is only supposed to match /tags/...

Okay, the other regexp that I kept commented out appears to match actual tags, as in it's useful for testing whether a string /is/ a tag:

#+BEGIN_SRC elisp
(org-re ":\\([[:alnum:]_@#%:]+\\):[ \t]*$")
#+END_SRC

While this one appears to match tags in a document, potentially in a list of tags:

#+BEGIN_SRC elisp
(org-re "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?")
#+END_SRC

Okay, I fixed it, I had an =if match= instead of a =while match= in the =matched-words-with-context= loop.

Now to profile and compare with the pre-fix-context version:

*Pre-context-fixed version:* master @ 5c30f38

#+NAME: context-fixed-test
#+BEGIN_SRC elisp :results value
  (profile-rifle 50 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          17.799054759  0.3559810951
org-heading-components                                        9350        2.6933843979  0.0002880625
helm-org-rifle-fontify-like-in-org-mode                       950         1.7538910299  0.0018462010
org-back-to-heading                                           11250       1.3298633500  0.0001182100
outline-back-to-heading                                       11250       1.1494924389  0.0001021771
goto-char                                                     37300       1.0525728939  2.821...e-05
search-forward-regexp                                         18600       0.9430047979  5.069...e-05
outline-next-heading                                          11300       0.7735385280  6.845...e-05
s-contains?                                                   50600       0.7211126610  1.425...e-05
rx-form                                                       1400        0.4769376879  0.0003406697
outline-previous-heading                                      9350        0.4475351999  4.786...e-05
line-beginning-position                                       20450       0.3628916579  1.774...e-05
line-end-position                                             10250       0.3234668489  3.155...e-05
list                                                          36850       0.3109050100  8.437...e-06
org-indent-refresh-maybe                                      1900        0.3052489690  0.0001606573
helm-org-rifle-prep-token                                     18700       0.3021837809  1.615...e-05
string-match                                                  71250       0.2578011050  3.618...e-06
buffer-substring-no-properties                                29350       0.2555603400  8.707...e-06
org-indent-add-properties                                     1900        0.2475959590  0.0001303136
org-at-heading-p                                              11200       0.2333956789  2.083...e-05
#+end_example

*Context-fixed version:* 2b5b12a

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          28.748935016  0.5749787003
search-forward-regexp                                         33700       3.2623649319  9.680...e-05
org-heading-components                                        9750        2.4923882399  0.0002556295
helm-org-rifle-fontify-like-in-org-mode                       950         1.9004250499  0.0020004474
goto-char                                                     43500       1.5172595929  3.487...e-05
s-matches?                                                    63200       1.3970165480  2.210...e-05
org-back-to-heading                                           11650       1.3835048189  0.0001187557
outline-back-to-heading                                       11650       1.3488680939  0.0001157826
outline-next-heading                                          11700       0.8288543339  7.084...e-05
line-beginning-position                                       48850       0.7972754510  1.632...e-05
line-end-position                                             24900       0.7767868229  3.119...e-05
string-match                                                  83750       0.6722922219  8.027...e-06
mapcar                                                        10778       0.5059252250  4.694...e-05
outline-previous-heading                                      9750        0.4670275909  4.790...e-05
org-at-heading-p                                              25850       0.4494715110  1.738...e-05
car                                                           130862      0.3298968730  2.520...e-06
org-indent-refresh-maybe                                      1900        0.3058012260  0.0001609480
org-indent-add-properties                                     1900        0.2488298529  0.0001309630
outline-on-heading-p                                          37500       0.2456449769  6.550...e-06
s-trim                                                        5050        0.2146568449  4.250...e-05
#+end_example

[2016-04-02 Sat 00:14] Well, that's definitely worse, although it's still probably fast enough, because the elp instrumentation makes it a lot slower.

I'm also noticing that when I eval the buffer of the old version, and then the new one, and back and forth, it's giving different results than when I start a new Emacs session before eval'ing each buffer.  The content-fixed version is still slower, but it's annoying that they are somehow interfering with each other...

Oh, I know what it probably is: =defvar= not changing already-defined vars.  Gah, I wish there were a "developer mode" that would automatically treat =defvar= as =setq=!  That might also be causing different results to be returned.

And on that note, notice that the old version is running =org-heading-components= 9350 times and the new one 9750 times (divided by 50 runs, of course).  That means the newer one is returning more results.  That's /probably/ a good thing--better than returning fewer results--but it's still an annoying discrepancy.

Well, anyway, it seems that the new version is working properly, even if it is a bit slower.  I can probably optimize it some from here by profiling it some more.  And it's probably still fast enough anyway.  I'm going to commit these test results and go from there.

[2016-04-02 Sat 00:24] I just noticed that the new version has =search-forward-regexp= while the old shows =re-search-forward=.  I guess I accidentally used one instead of the other.  And I didn't have =re-= in the =profile-rifle= macro, so it wasn't being instrumented.  But I can't even find out what the difference between those two functions is.  Their docstrings are identical, but =re-search-forward= says it's "an interactive built-in function in `C source code'" and =search-forward-regexp= says it's an "interactive built-in function".  If one were an alias for the other, wouldn't it say so, like other functions do?  And I just googled it, and I can't even find any discussions disambiguating them.

Well, I guess I will change all the =search-forward-regexp= to =re-search-forward= and profile it again, now with =re-= instrumented...

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          29.720079127  0.5944015825
re-search-forward                                             95750       10.653707145  0.0001112658
helm-org-rifle-fontify-like-in-org-mode                       950         3.115803256   0.0032797929
org-heading-components                                        9750        2.0726401679  0.0002125784
goto-char                                                     43500       1.5346791419  3.527...e-05
s-matches?                                                    63200       1.3961592560  2.209...e-05
org-back-to-heading                                           11650       1.2585600799  0.0001080309
outline-back-to-heading                                       11650       1.2252464660  0.0001051713
outline-next-heading                                          11700       1.0289735719  8.794...e-05
string-match                                                  83850       0.9593000099  1.144...e-05
outline-previous-heading                                      9750        0.8035638840  8.241...e-05
line-beginning-position                                       48850       0.8014680960  1.640...e-05
line-end-position                                             24900       0.7814555490  3.138...e-05
re-search-backward                                            13950       0.6276933279  4.499...e-05
buffer-substring-no-properties                                44700       0.4611391599  1.031...e-05
s-trim                                                        5050        0.3644793139  7.217...e-05
mapcar                                                        10780       0.3609109789  3.347...e-05
org-indent-refresh-maybe                                      1900        0.3286191740  0.0001729574
org-unfontify-region                                          950         0.3180826990  0.0003348238
org-at-heading-p                                              25850       0.3019532499  1.168...e-05
#+end_example

Well, that made it a bit slower... and =re-search-forward= is running 1915 times per run, which seems like a lot.  Well, just for fun, let's see if =search-forward-regexp= is any different...

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          29.894388876  0.5978877775
search-forward-regexp                                         43500       9.9810062590  0.0002294484
helm-org-rifle-fontify-like-in-org-mode                       950         2.8640568999  0.0030147967
org-heading-components                                        9750        2.5292111220  0.0002594062
s-matches?                                                    63200       1.5561717319  2.462...e-05
goto-char                                                     43500       1.5376464950  3.534...e-05
org-back-to-heading                                           11650       1.2684373279  0.0001088787
outline-back-to-heading                                       11650       1.2354534740  0.0001060475
string-match                                                  83850       0.9752567150  1.163...e-05
outline-next-heading                                          11700       0.8854215550  7.567...e-05
line-beginning-position                                       48850       0.8027929070  1.643...e-05
line-end-position                                             24900       0.7844873019  3.150...e-05
re-search-backward                                            13950       0.7822806550  5.607...e-05
re-search-forward                                             52250       0.7321030019  1.401...e-05
outline-previous-heading                                      9750        0.6612776079  6.782...e-05
buffer-substring-no-properties                                44700       0.6150929480  1.376...e-05
org-indent-refresh-maybe                                      1900        0.4929963640  0.0002594717
org-indent-add-properties                                     1900        0.4216444500  0.0002219181
mapcar                                                        10780       0.3625142850  3.362...e-05
s-join                                                        12650       0.3601353390  2.846...e-05
#+end_example

Well, seems about the same.  Some other functions are calling =re-search-forward=.  I guess I'll stick to =re-search-forward= for consistency.

Let's see if I can optimize this regexp, because it's the one used for finding the next matching node:

#+BEGIN_SRC elisp
(positive-re (mapconcat 'helm-org-rifle-prep-token input "\\|"))
#+END_SRC

Wait...I think I can't do that, because each token has to be handled separately in case it's a tag.  At least, that's the way I found that works.

I just realized something: because =re-= wasn't instrumented when I profiled the pre-context-fix code, that probably made the test runs a lot faster.  I should rerun that test now that I've instrumented =re-=:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          18.989564333  0.3797912866
re-search-forward                                             61250       3.4628969270  5.653...e-05
org-heading-components                                        9350        2.690181023   0.0002877198
helm-org-rifle-fontify-like-in-org-mode                       950         1.8528630730  0.0019503821
goto-char                                                     37300       1.3264769309  3.556...e-05
org-back-to-heading                                           11250       1.3099172920  0.0001164370
outline-back-to-heading                                       11250       1.2793007219  0.0001137156
search-forward-regexp                                         18600       0.9837737700  5.289...e-05
s-contains?                                                   50600       0.9775941719  1.932...e-05
outline-next-heading                                          11300       0.8469392419  7.495...e-05
re-search-backward                                            13400       0.6245546379  4.660...e-05
outline-previous-heading                                      9350        0.4990147979  5.337...e-05
org-indent-refresh-maybe                                      1900        0.4647722440  0.0002446169
line-beginning-position                                       20450       0.4323783559  2.114...e-05
line-end-position                                             10250       0.3633604599  3.544...e-05
helm-org-rifle-prep-token                                     18700       0.3031164060  1.620...e-05
org-indent-add-properties                                     1900        0.2517753239  0.0001325133
buffer-substring-no-properties                                29350       0.247449885   8.431...e-06
org-at-heading-p                                              11200       0.2308021850  2.060...e-05
s-join                                                        12200       0.2029973209  1.663...e-05
#+end_example

Uh...that's a lot slower...even slower than the context-fixed version.  And it's running =re-search-forward= about 1/3rd fewer times, yet it's still slower.  That means the context-fixed version is faster...yet it doesn't /feel/ faster...  This is getting really confusing.

...Or not!  I ran it again, and this time it was back to 0.38 seconds per run, instead of the 0.88 that it showed.  So the old version /is/ faster.  Argh, I even restarted Emacs between runs, but the results are still not always consistent.

(Haha, if anyone reads this on GitHub, they're going to be confused, because GitHub doesn't display results blocks in their Org renderer.)

Back to testing the context-fixed version:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          30.890125471  0.6178025094
re-search-forward                                             95750       10.759003013  0.0001123655
org-heading-components                                        9750        3.0528847219  0.0003131163
s-matches?                                                    63200       1.9809823760  3.134...e-05
goto-char                                                     43500       1.5808144250  3.634...e-05
org-back-to-heading                                           11650       1.3265871900  0.0001138701
outline-back-to-heading                                       11650       1.2950595060  0.0001111639
outline-next-heading                                          11700       1.0353336260  8.849...e-05
line-beginning-position                                       48850       1.0339746409  2.116...e-05
line-end-position                                             24900       1.0186344770  4.090...e-05
outline-previous-heading                                      9750        0.8171171010  8.380...e-05
helm-org-rifle-fontify-like-in-org-mode                       950         0.8004842739  0.0008426150
string-match                                                  83850       0.6619865150  7.894...e-06
re-search-backward                                            13950       0.6425335970  4.605...e-05
buffer-substring-no-properties                                44700       0.4572488249  1.022...e-05
car                                                           130863      0.3309231389  2.528...e-06
s--truthy?                                                    63200       0.3191290470  5.049...e-06
list                                                          65650       0.1679614680  2.558...e-06
org-indent-refresh-maybe                                      1900        0.1644345459  8.654...e-05
delete-dups                                                   9750        0.1581602390  1.622...e-05
#+end_example

Maybe the problem is [[file:helm-org-rifle.el::thereis%20(s-matches?%20re%20target)))][here]]:

#+BEGIN_SRC elisp
(s-matches? re target)
#+END_SRC

In the pre-context-fix version, I'm using:

#+BEGIN_SRC elisp
(s-contains? token target t)
#+END_SRC

I think I changed to the regexp version because the =s-contains?= version was doing substring matching, which I don't want.  Let's switch it real quick just to see if that's the problem:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          29.681379652  0.5936275930
re-search-forward                                             78050       10.705968030  0.0001371680
org-heading-components                                        9750        2.3193180259  0.0002378787
goto-char                                                     43500       1.5864029119  3.646...e-05
org-back-to-heading                                           10850       1.1765637859  0.0001084390
outline-back-to-heading                                       10850       1.1455293570  0.0001055787
helm-org-rifle-fontify-like-in-org-mode                       550         1.1138197010  0.0020251267
line-beginning-position                                       48450       1.0433171030  2.153...e-05
outline-next-heading                                          10900       1.0355597489  9.500...e-05
line-end-position                                             24500       1.0200701619  4.163...e-05
s-contains?                                                   58300       0.8684338029  1.489...e-05
s-join                                                        11450       0.6645958719  5.804...e-05
outline-previous-heading                                      9750        0.6607329249  6.776...e-05
re-search-backward                                            13550       0.6436711090  4.750...e-05
mapconcat                                                     11550       0.6339636089  5.488...e-05
buffer-substring-no-properties                                44600       0.4622889649  1.036...e-05
mapcar                                                        10380       0.3559940170  3.429...e-05
car                                                           121013      0.3262029620  2.695...e-06
string-match                                                  73550       0.3073863820  4.179...e-06
org-at-heading-p                                              25050       0.2945103339  1.175...e-05
#+end_example

Eh, it's only about 20ms faster per run, although =s-contains?= is more than twice as fast as =s-matches?=.  But it's still such a short time that it doesn't make much difference.

This is probably where the =next-gen= branch would be easier to optimize.  Even if all the extra function calls took their toll, at least I could profile each one separately.  With this, I see all those =re-search-forward= calls listed, but it's hard to figure out why that's making it slower than the pre-context-fix version.

Okay, I think I see what the problem is, or almost:

Pre-context-fix: =re-search-forward 61250 3.4628969270 5.653...e-05=
Post-context-fix: =re-search-forward 78050 10.705968030 0.0001371680=

The time per call to this function in the old version is much shorter, so the problem must be the regexp complexity.  And that is a bit annoying, because I thought I was being careful to make it simpler, like by wrapping the whole regexp in the word-boundary matcher instead of each token in the =or= group.

It's almost surely this one: ~(re-search-forward positive-re node-end t)~, because the other two are the negation one (which isn't being called in this test), and the per-node matcher ~(re-search-forward positive-re nil t)~, which is only run once per partially-matching node, in the main loop, while the other one runs multiple times per partially-matching node.  They both use the same regexp though.  Maybe if I can optimize the regexp used in that one...

I'm not sure that I can, though, because IIRC I had to do it this way to avoid substring matching:

#+BEGIN_SRC elisp
  (positive-re (mapconcat 'helm-org-rifle-prep-token input "\\|"))
#+END_SRC

Maybe having each token wrapped with =helm-org-rifle-prep-token= is the problem, but I think if I change that, I'll get substring matching, which I don't want.  Also there's [[*Weird%20heading-only,%20second-word%20substring%20matching][this]]: while before I /thought/ I wasn't getting substring matching, it might be that I actually was, but only for tokens after the first.

Sigh.  I can see how having a testing framework for this would help a lot...

Well, I'm going to try a quick experiment: the faster version has this:

#+BEGIN_SRC elisp
  (setq matching-positions-in-node
        (or (cl-loop for token in all-tokens
                     do (goto-char node-beg)
                     while (re-search-forward (helm-org-rifle-prep-token token) node-end t)
                     when negations
                     when (cl-loop for negation in negations
                                   thereis (s-matches? negation
                                                       (buffer-substring-no-properties (line-beginning-position)
                                                                                       (line-end-position))))
                     return nil
                     collect (line-beginning-position) into result
                     do (end-of-line)
                     finally return (sort (delete-dups result) '<))
            ;; Negation found; skip node
            (throw 'negated (goto-char node-end))))
#+END_SRC

And the slower version has this:

#+BEGIN_SRC elisp
  (when (and negations
             (re-search-forward negations-re node-end t))
    (throw 'negated (goto-char node-end)))
  
  (setq matching-positions-in-node
        (cl-loop initially (goto-char node-beg)
                 while (re-search-forward positive-re node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
#+END_SRC

It's hard for me to imagine how the first one is faster, even without negations, because it should be running more searches, about one for each token times the number of matching lines, rather than one for the number of matching lines.  And =helm-org-rifle-prep-token= is being called...well it should be a /lot/ of times, once per token per node, at least, so that /should/ be much slower! But maybe the more complex regexp is /that/ much slower, so that running more, simpler searches is faster.  Let's find out... one, ta-hoo-hoo, tha-ree...

#+BEGIN_SRC elisp
  (setq matching-positions-in-node
        (cl-loop for token in input
                 do (goto-char node-beg)
                 while (re-search-forward (helm-org-rifle-prep-token token) node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
#+END_SRC

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          30.736917460  0.6147383492
re-search-forward                                             110600      12.773894478  0.0001154963
org-heading-components                                        9750        2.4618781539  0.0002525003
helm-org-rifle-fontify-like-in-org-mode                       850         1.8120636949  0.0021318396
line-beginning-position                                       35200       1.5948968589  4.530...e-05
goto-char                                                     38750       1.5266306220  3.939...e-05
org-back-to-heading                                           11450       1.4955711799  0.0001306175
outline-back-to-heading                                       11450       1.4644250010  0.0001278973
outline-next-heading                                          11500       1.1824791589  0.0001028242
helm-org-rifle-prep-token                                     19400       1.0364527230  5.342...e-05
s-matches?                                                    39950       0.9029048190  2.260...e-05
outline-previous-heading                                      9750        0.8225591450  8.436...e-05
re-search-backward                                            13850       0.6591115870  4.758...e-05
org-indent-refresh-maybe                                      1700        0.4569549119  0.0002687970
concat                                                        59950       0.3421275590  5.706...e-06
org-indent-add-properties                                     1700        0.2434831740  0.0001432253
org-indent-notify-modified-headline                           1700        0.1823105449  0.0001072414
mapconcat                                                     12450       0.1753660190  1.408...e-05
car                                                           75363       0.1692585069  2.245...e-06
list                                                          58150       0.1671702790  2.874...e-06
#+end_example

Well, that's basically the same.  Even though =helm-org-rifle-prep-token= is being called 19,400 times now (whereas before it wasn't even on the chart), the overall run is about the same speed.  And =re-search-forward= is being called 110,600 times instead of 78,050 times, and that's adding two seconds to the overall time, yet the overall time is only 1 second slower, and each run is only 0.02 seconds slower.

I really don't know.  It's probably still acceptably fast, but I'm not happy that it's 240 ms slower per run than it was before.

Wait...is it the context matching that's slowing it down?  That would seem to make sense, but I don't see =string-match= or =match-string-no-properties= on the chart, which are called a lot in the context-getting part.  Again, this is where the =next-gen= branch would be easier to profile, because that part would be in a separate function, which would show up on the benchmark.

Okay, so let's try disabling the context-matching and see if that helps narrow it down.

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          30.781087232  0.6156217446
re-search-forward                                             110600      12.989410668  0.0001174449
org-heading-components                                        9750        2.0101349390  0.0002061676
helm-org-rifle-fontify-like-in-org-mode                       850         2.0032276699  0.0023567384
line-beginning-position                                       35200       1.6018393130  4.550...e-05
goto-char                                                     38750       1.5316418570  3.952...e-05
org-back-to-heading                                           11450       1.1903071840  0.0001039569
outline-back-to-heading                                       11450       1.1586320740  0.0001011905
s-matches?                                                    39950       1.0665855099  2.669...e-05
helm-org-rifle-prep-token                                     19400       1.0471090219  5.397...e-05
outline-next-heading                                          11500       0.8812347759  7.662...e-05
outline-previous-heading                                      9750        0.6750363980  6.923...e-05
re-search-backward                                            13850       0.6601655850  4.766...e-05
s-join                                                        12350       0.5171406150  4.187...e-05
org-activate-plain-links                                      1200        0.3440198649  0.0002866832
mapconcat                                                     12450       0.3296189910  2.647...e-05
list                                                          58150       0.3267329869  5.618...e-06
org-indent-refresh-maybe                                      1700        0.3121118990  0.0001835952
string-match                                                  61000       0.2487342409  4.077...e-06
buffer-substring-no-properties                                20750       0.2216961110  1.068...e-05
#+end_example

Wow...nope.  I set the context matches to a hardcoded string, and it actually took longer.  That makes noooooo sense.  I guess the context matching isn't the problem.

Ok then, let's see if avoiding substring matches is really the problem.  Let's change that back so that it does match substrings and see if it's faster again:

Uh, before I do that... I see a discrepancy in the code:

#+BEGIN_SRC elisp
  (setq matching-positions-in-node
        (cl-loop initially (goto-char node-beg)
                 while (re-search-forward positive-re node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
  
  ;; Get list of line-strings containing any token
  ;; (setq matching-lines-in-node
  ;;       (cl-loop for pos in matching-positions-in-node
  ;;                do (goto-char pos)
  ;;                ;; Get text of each matching line
  ;;                for string = (buffer-substring-no-properties (line-beginning-position)
  ;;                                                             (line-end-position))
  ;;                unless (org-at-heading-p) ; Leave headings out of list of matched lines
  ;;                ;; (DISPLAY . REAL) format for Helm
  ;;                collect `(,string . (,buffer ,pos))))
  (setq matching-positions-in-node
        (cl-loop for token in input
                 do (goto-char node-beg)
                 while (re-search-forward (helm-org-rifle-prep-token token) node-end t)
                 collect (line-beginning-position) into result
                 do (end-of-line)
                 finally return (sort (delete-dups result) '<)))
#+END_SRC 

Somehow I put two of these loops in while commenting out the =matching-lines-in-node= part.  So running that loop twice could explain the slowdown...but then how were any context lines being displayed at all?  Wow...how did I manage to do that...  Oh I think I see, when I was testing the other =matching-positions-in-node= loop, I commented out and replaced the wrong one.  So...let's fix that and profile again:

#+CALL: context-fixed-test[]()

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       50          25.136648485  0.5027329696
re-search-forward                                             81250       9.2580263800  0.0001139449
org-heading-components                                        9750        2.3233045519  0.0002382876
helm-org-rifle-fontify-like-in-org-mode                       950         1.8861932009  0.0019854665
org-back-to-heading                                           11650       1.5047206050  0.0001291605
outline-back-to-heading                                       11650       1.4730061889  0.0001264382
goto-char                                                     38500       1.3475950079  3.500...e-05
s-matches?                                                    52300       1.2050915929  2.304...e-05
outline-next-heading                                          11700       1.0363664480  8.857...e-05
helm-org-rifle-prep-token                                     19400       0.9003198629  4.640...e-05
outline-previous-heading                                      9750        0.6790285010  6.964...e-05
re-search-backward                                            13950       0.6644822260  4.763...e-05
line-beginning-position                                       20850       0.4335685669  2.079...e-05
outline-on-heading-p                                          23050       0.3818343959  1.656...e-05
line-end-position                                             10450       0.3660547069  3.502...e-05
string-match                                                  74450       0.3551845139  4.770...e-06
org-indent-refresh-maybe                                      1900        0.3207771170  0.0001688300
buffer-substring-no-properties                                30250       0.2616993640  8.651...e-06
org-indent-add-properties                                     1900        0.2569457650  0.0001352346
org-at-heading-p                                              11400       0.2390862280  2.097...e-05
#+end_example

Okay, that is slightly faster, but this matches substrings, which I don't want.  So if I kept this, it would be a slight improvement over the current master in that it would fix the context matching while being a little bit slower.

I wonder if I could compromise and match substrings but only at the beginning of words (or after punctuation).  That could be useful anyway, because it would avoid the "did I use a plural" problem.  Let's see if I can try it...

Wait, if I do that, it might mess up the tags matching that took so long to fix.

I wonder if I should separate out the tags matching.  I already have it getting a list of tags in a separate string.  If I removed tags-matching tokens from the input and matched them separately, maybe it would let me use a simpler regexp for everything else and avoid the prep function.  I should probably make another branch to test that idea...sigh.  And I don't even know if that would improve performance.  I'd have to first separate out the tags matching, then verify that it works properly, and then simplify the main =positive-re= regexp, and then see if it is faster.

I think I'm going to stop here.  It seems to work properly right now: context-matching, tag-matching, avoids substring matches, and negation works.  And it seems fast enough, even if it is slower than before.  Maybe there is some combination of these changes that makes everything work at about the same speed as before, but I think trying to figure it out is too complicated with this big candidates-getting function.  I think it would be better to settle on this code that works correctly, and then go back to the =next-gen= branch and try to improve that, which is structured in a simpler way.

[2016-04-02 Sat 02:21] I decided to test in the MELPA sandbox before merging with master and pushing, and it's a good thing I did, because I discovered another weird bug: if the =show-tags= setting is off, the results are way off.  Probably a simpleish logic error in the code somewhere...but I think at this point I should just remove that setting.  As it is it's off by default, and I wonder how many people have gotten bad results because of it and decided that this package is no good.  I doubt anyone would want it off anyway, and it doesn't seem to hurt performance.  So let's just remove that so it's consistent...
** UNDERWAY elp profiling


#+BEGIN_SRC elisp
(setq helm-org-rifle-show-path nil)
(setq helm-org-rifle-show-path t)
#+END_SRC

*** Testing with helm: before negation support                  :read_only:
#+BEGIN_SRC elisp
(setq argh-how-many-buffers 0)
(message "This many buffers: %s" argh-how-many-buffers)
(setq argh-how-many-times-getc-called 0)
(message "This many times: %s" argh-how-many-times-getc-called)
#+END_SRC

#+BEGIN_SRC elisp :results value
  (progn
    (dolist (p '("helm-" "org-" "string-" "s-"))
      (elp-instrument-package p))
    (let ((helm-pattern "emacs helm"))
      (helm-org-rifle))
    (elp-results)
    (elp-restore-all)
    (buffer-substring-no-properties (point-min) (point-max)))
#+END_SRC

#+RESULTS:
#+begin_example
helm-org-rifle                                                1           21.149816496  21.149816496
helm-internal                                                 1           21.146028492  21.146028492
helm-display-buffer                                           1           0.015992741   0.015992741
helm-default-display-buffer                                   1           0.015959396   0.015959396
helm-split-window-default-fn                                  2           0.015504805   0.0077524025
helm-window-in-direction                                      2           0.015404318   0.007702159
helm-cleanup                                                  1           0.005956688   0.005956688
helm-frame-or-window-configuration                            2           0.00564105    0.002820525
helm-org-rifle-get-sources                                    1           0.003752977   0.003752977
string-match                                                  3553        0.0031005809  8.726...e-07
helm-make-source                                              3           0.001922106   0.000640702
org-buffer-list                                               1           0.001704984   0.001704984
helm--setup-source                                            3           0.0013488509  0.000449617
helm-source--header-line                                      3           0.0011306280  0.0003768760
helm-initialize                                               1           0.000588538   0.000588538
helm-initial-setup                                            1           0.000510501   0.000510501
helm--create-source                                           3           0.000273995   9.133...e-05
helm-source-sync                                              3           0.000238082   7.936...e-05
helm-log-run-hook                                             12          0.0002350079  1.958...e-05
helm--run-init-hooks                                          2           0.000163177   8.15885e-05
helm-get-sources                                              5           0.000135961   2.71922e-05
helm-create-helm-buffer                                       1           0.000131969   0.000131969
helm-funcall-foreach                                          2           0.000125873   6.29365e-05
helm-compile-sources                                          1           8.7179e-05    8.7179e-05
helm-buffer-get                                               5           5.823e-05     1.1646e-05
helm-handle-winner-boring-buffers                             1           5.4042e-05    5.4042e-05
helm-action-window                                            10          5.110...e-05  5.1105e-06
helm-clean-up-minibuffer                                      1           5.0868e-05    5.0868e-05
helm--remap-mouse-mode                                        2           4.403e-05     2.2015e-05
helm-ff-save-history                                          1           4.3852e-05    4.3852e-05
helm-org-rifle-buffer-invisible-p                             5           4.0771e-05    8.1542e-06
helm-file-completion-source-p                                 1           3.9612e-05    3.9612e-05
helm-source-mm-get-search-or-match-fns                        3           3.739e-05     1.246...e-05
helm-get-current-source                                       1           3.4542e-05    3.4542e-05
helm-update-source-p                                          3           2.9221e-05    9.740...e-06
helm-prevent-switching-other-window                           2           2.8107e-05    1.40535e-05
s-starts-with?                                                5           2.5263e-05    5.0526e-06
helm-log                                                      61          2.303...e-05  3.776...e-07
helm--current-buffer                                          1           2.0959e-05    2.0959e-05
helm-clear-visible-mark                                       1           2.0575e-05    2.0575e-05
helm-window                                                   1           1.5778e-05    1.5778e-05
helm-compile-source--info-index                               3           1.536...e-05  5.121...e-06
helm-parse-keys                                               1           1.4924e-05    1.4924e-05
helm-restore-position-on-quit                                 1           1.3328e-05    1.3328e-05
helm-current-position                                         2           1.279...e-05  6.397...e-06
helm-attrset                                                  3           1.2792e-05    4.264e-06
helm-initialize-overlays                                      1           1.0226e-05    1.0226e-05
helm-setup-user-source                                        3           1.019...e-05  3.397...e-06
helm-match-line-cleanup                                       1           9.55e-06      9.55e-06
helm-alive-p                                                  1           6.474e-06     6.474e-06
helm-compile-source--type                                     3           5.868...e-06  1.956...e-06
helm-compile-source--candidates-file                          3           5.813e-06     1.937...e-06
helm-match-functions                                          3           5.695...e-06  1.898...e-06
helm-search-functions                                         3           5.488...e-06  1.829...e-06
helm-delayed-source-p                                         3           4.737...e-06  1.579...e-06
helm-make-actions                                             3           3.953e-06     1.317...e-06
string-prefix-p                                               5           3.477...e-06  6.954e-07
string-width                                                  5           2.828...e-06  5.657...e-07
helm-kill-async-processes                                     2           2.012e-06     1.006e-06
helm-interpret-value                                          3           1.797e-06     5.99e-07
helm-compile-source--candidates-in-buffer                     3           1.788e-06     5.96e-07
helm-mklist                                                   3           1.764...e-06  5.88e-07
helm-compile-source--dummy                                    3           1.683e-06     5.61e-07
helm-resume-p                                                 3           1.42e-06      4.733...e-07
helm-recent-push                                              1           1.399e-06     1.399e-06
helm-get-attribute-from-source-type                           3           1.371e-06     4.570...e-07
helm-set-local-variable                                       1           1.261e-06     1.261e-06
helm-normalize-sources                                        2           1.235e-06     6.175e-07
helm-initialize-persistent-action                             1           1.192e-06     1.192e-06
helm-reset-yank-point                                         2           1.177e-06     5.885e-07
helm-get-previous-header-pos                                  1           9.7e-07       9.7e-07
helm-log-save-maybe                                           1           9.02e-07      9.02e-07
helm-find-files--reset-level-tree                             1           7.84e-07      7.84e-07
helm-get-next-header-pos                                      1           7e-07         7e-07
string-equal                                                  1           2.75e-07      2.75e-07
helm-read-pattern-maybe                                       1           0             0.0
helm-other-buffer                                             1           0             0.0
helm-update                                                   1           0             0.0
helm-keyboard-quit                                            1           0             0.0
#+end_example

**** Results

***** DONE helm-org-rifle-get-sources 

This function is working correctly, returning the number of sources that it should.

***** DONE helm-org-rifle-get-candidates-in-buffer

This function works correctly and pretty quickly.

***** TODO helm-org-rifle-get-candidates-in-buffer called 10 times for each buffer

However, Helm seems to be calling this function, the =:candidates= function...sometimes 10 times per buffer, sometimes less, like this time where it did it 6 times for each buffer (input was "emacs"):

#+BEGIN_EXAMPLE txt
Evaluate this elisp code block on your system? (y or n) y
executing Elisp code block...
This many sources: 18
ARGH called for buffer: test.org
ARGH called for buffer: README.org\helm-org-rifle
ARGH called for buffer: inbox.org
ARGH called for buffer: README.org\org-bookmark-heading
ARGH called for buffer: main.org
ARGH called for buffer: school.org
ARGH called for buffer: sparky.org
ARGH called for buffer: prayers.org
ARGH called for buffer: calendar.org
ARGH called for buffer: log.org
ARGH called for buffer: people.org
ARGH called for buffer: bible.org
ARGH called for buffer: books.org
ARGH called for buffer: misc.org
ARGH called for buffer: posts.org
ARGH called for buffer: quotes.org
ARGH called for buffer: reference.org
ARGH called for buffer: research.org
ARGH called for buffer: test.org
ARGH called for buffer: README.org\helm-org-rifle
ARGH called for buffer: inbox.org
ARGH called for buffer: README.org\org-bookmark-heading
ARGH called for buffer: main.org
ARGH called for buffer: school.org
ARGH called for buffer: sparky.org
ARGH called for buffer: prayers.org
ARGH called for buffer: calendar.org
ARGH called for buffer: log.org
ARGH called for buffer: people.org
ARGH called for buffer: bible.org
ARGH called for buffer: books.org
ARGH called for buffer: misc.org
ARGH called for buffer: posts.org
ARGH called for buffer: quotes.org
ARGH called for buffer: reference.org
ARGH called for buffer: research.org
ARGH called for buffer: test.org
ARGH called for buffer: README.org\helm-org-rifle
ARGH called for buffer: inbox.org
ARGH called for buffer: README.org\org-bookmark-heading
ARGH called for buffer: main.org
ARGH called for buffer: school.org
ARGH called for buffer: sparky.org
ARGH called for buffer: prayers.org
ARGH called for buffer: calendar.org
ARGH called for buffer: log.org
ARGH called for buffer: people.org
ARGH called for buffer: bible.org
ARGH called for buffer: books.org
ARGH called for buffer: misc.org
ARGH called for buffer: posts.org
ARGH called for buffer: quotes.org
ARGH called for buffer: reference.org
ARGH called for buffer: research.org
ARGH called for buffer: test.org
ARGH called for buffer: README.org\helm-org-rifle
ARGH called for buffer: inbox.org
ARGH called for buffer: README.org\org-bookmark-heading
ARGH called for buffer: main.org
ARGH called for buffer: school.org
ARGH called for buffer: sparky.org
ARGH called for buffer: prayers.org
ARGH called for buffer: calendar.org
ARGH called for buffer: log.org
ARGH called for buffer: people.org
ARGH called for buffer: bible.org
ARGH called for buffer: books.org
ARGH called for buffer: misc.org
ARGH called for buffer: posts.org
ARGH called for buffer: quotes.org
ARGH called for buffer: reference.org
ARGH called for buffer: research.org
ARGH called for buffer: test.org
ARGH called for buffer: README.org\helm-org-rifle
ARGH called for buffer: inbox.org
ARGH called for buffer: README.org\org-bookmark-heading
ARGH called for buffer: main.org
ARGH called for buffer: school.org
ARGH called for buffer: sparky.org
ARGH called for buffer: prayers.org
ARGH called for buffer: calendar.org
ARGH called for buffer: log.org
ARGH called for buffer: people.org
ARGH called for buffer: bible.org
ARGH called for buffer: books.org
ARGH called for buffer: misc.org
ARGH called for buffer: posts.org
ARGH called for buffer: quotes.org
ARGH called for buffer: reference.org
ARGH called for buffer: research.org
ARGH called for buffer: test.org
ARGH called for buffer: README.org\helm-org-rifle
ARGH called for buffer: inbox.org
ARGH called for buffer: README.org\org-bookmark-heading
ARGH called for buffer: main.org
ARGH called for buffer: school.org
ARGH called for buffer: sparky.org
ARGH called for buffer: prayers.org
ARGH called for buffer: calendar.org
ARGH called for buffer: log.org
ARGH called for buffer: people.org
ARGH called for buffer: bible.org
ARGH called for buffer: books.org
ARGH called for buffer: misc.org
ARGH called for buffer: posts.org
ARGH called for buffer: quotes.org
ARGH called for buffer: reference.org
ARGH called for buffer: research.org
Code block evaluation complete.
#+END_EXAMPLE

Okay, I think I see what it's doing: Helm is calling the candidates function once for every character that is typed, plus one more time.  When I type =emacs= it calls it 6 times per buffer, and when I type =e= it calls it twice per buffer.  The =:delay= works in that it doesn't start getting candidates until that much time has elapsed after I've finished typing, but then it goes ahead and calls it for every character I typed, plus one.

Problem might be in =helm-update= or =helm-process-delayed-sources=...

*** Testing without helm
#+BEGIN_SRC elisp :results value
    (progn
      (let ((buffers (remove-if 'helm-org-rifle-buffer-invisible-p (org-buffer-list nil t)))
            (string "emacs helm";; (read-from-minibuffer "Words: ")
                    ))
        (dolist (p '("helm-" "org-" "string-" "s-"))
          (elp-instrument-package p))
        (dolist (buffer buffers)
          (helm-org-rifle-get-candidates-in-buffer buffer string)))
      (elp-results)
      (elp-restore-all)
  (buffer-substring-no-properties (point-min) (point-max)))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       18          0.325021298   0.0180567387
string-match                                                  1347        0.0362915149  2.694...e-05
org-heading-components                                        376         0.0335699080  8.928...e-05
org-back-to-heading                                           412         0.018007849   4.370...e-05
s-contains?                                                   1114        0.0121319489  1.089...e-05
helm-org-rifle-fontify-like-in-org-mode                       18          0.01178797    0.0006548872
org-indent-refresh-maybe                                      36          0.0028632780  7.953...e-05
org-at-heading-p                                              706         0.0020766779  2.941...e-06
org-indent-add-properties                                     36          0.0017027310  4.729...e-05
org-get-limited-outline-regexp                                72          0.0010015760  1.391...e-05
org-activate-plain-links                                      23          0.0004599949  1.999...e-05
s--truthy?                                                    1114        0.0003860220  3.465...e-07
org-indent-notify-modified-headline                           36          0.0003555730  9.877...e-06
org-activate-bracket-links                                    18          0.0003234190  1.796...e-05
org-do-latex-and-related                                      18          0.000282822   1.571...e-05
org-activate-footnote-links                                   18          0.0002406200  1.336...e-05
org-reduced-level                                             376         0.0002319499  6.168...e-07
org-fontify-meta-lines-and-blocks                             18          0.0002315430  1.286...e-05
org-string-nw-p                                               18          0.000225051   1.250...e-05
org-unfontify-region                                          18          0.000187095   1.039...e-05
org-footnote-next-reference-or-definition                     18          0.0001767840  9.821...e-06
s-join                                                        54          0.0001765719  3.269...e-06
org-in-src-block-p                                            10          0.0001672479  1.672...e-05
org-activate-tags                                             18          0.000155625   8.645...e-06
org-fontify-meta-lines-and-blocks-1                           18          0.0001549140  8.606...e-06
org-string-match-p                                            18          0.0001511729  8.398...e-06
org-do-emphasis-faces                                         18          0.000141394   7.855...e-06
org-activate-dates                                            18          0.000104557   5.808...e-06
s-pad-left                                                    18          0.0001032720  5.737...e-06
org-activate-angle-links                                      18          9.853...e-05  5.474...e-06
string-match-p                                                18          9.2952e-05    5.164e-06
org-bullets-level-char                                        18          8.3399e-05    4.633...e-06
org-activate-code                                             18          5.2719e-05    2.928...e-06
org-get-level-face                                            54          5.143...e-05  9.524...e-07
org-link-unescape                                             5           5.1e-05       1.02e-05
org-remove-flyspell-overlays-in                               10          4.6203e-05    4.6203e-06
org-font-lock-add-priority-faces                              18          3.870...e-05  2.150...e-06
org-remove-font-lock-display-properties                       18          3.099...e-05  1.721...e-06
org-hide-wide-columns                                         18          2.987e-05     1.659...e-06
org-before-change-function                                    36          2.4329e-05    6.758...e-07
string-to-char                                                36          1.481...e-05  4.114...e-07
org-font-lock-hook                                            18          1.462...e-05  8.127...e-07
org-activate-target-links                                     18          1.361...e-05  7.564...e-07
org-fontify-entities                                          18          1.223...e-05  6.799...e-07
org-font-lock-add-tag-faces                                   18          9.402...e-06  5.223...e-07
org-raise-scripts                                             18          7.807e-06     4.337...e-07
#+end_example

** DONE buffer-name-matching

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "test.org emacs")
(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "test.org") "inbox.org emacs")
#+END_SRC

** DONE Matching symbol parts

#+BEGIN_SRC elisp
;; This should return the "Target heading" heading too
(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "test.org") "face")

(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "face helm")
(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "testtemp.org") "face helm")
#+END_SRC

This does not work:

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (token "face"))
    (string-match (concat "\\_<" token "\\_>") target))
#+END_SRC

#+RESULTS:

Which is strange, because =\\_<= is supposed to be the symbol-boundary character...

This works but isn't what we want:

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (token "face"))
    (string-match token target))
#+END_SRC

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (token "face"))
    (string-match (concat "\\b" token "\\b") target))
#+END_SRC

This may do it:

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (token "face"))
    (string-match (concat "\\W" token "\\W") target))
#+END_SRC

It matches =face= okay, but not =helm= because of the quote.

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (token "helm"))
    (string-match (concat "\\(\\W\\|\\_<\\)" token "\\(\\W\\|\\_>\\)") target))
#+END_SRC

Wow, that "'helm-selection" really doesn't want to be matched...

This might do it...

#+BEGIN_SRC elisp
(string-match "\\(\\B\\|\\W\\)face" "(face-remap-set-base 'helm-selection")
#+END_SRC

Seems to work... now for the real test...

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (token "selection"))
    (string-match (concat "\\(\\B\\|\\W\\)" token "\\(\\W\\|\\B\\)") target))
#+END_SRC

I think it works!  Let's try it for real...

Buuuuut it doesn't match "selection".  Wow.

#+BEGIN_SRC elisp
  (let ((target "(face-remap-set-base 'helm-selection")
        (tokens '("face" "helm" "blah" "selection" "base")))
    (cl-loop for token in tokens
             when (string-match (concat "\\(\\B\\|\\W\\|\\_<\\|[[:punct:]]\\)" token "\\(\\B\\|\\W\\|\\_>\\|[[:punct:]]\\)") target)
             collect token))
#+END_SRC

Ok, this seems to match for "face", "helm", and "selection" and "base" but not "blah".

Okay, this seems to work:

#+BEGIN_SRC elisp
(defcustom helm-org-rifle-re-begin-part
  "\\(\\B\\|\\W\\|\\_<\\|[[:punct:]]\\)"
  "Argh"
  :group 'helm-org-rifle :type 'regexp)

(defcustom helm-org-rifle-re-end-part
  "\\(\\B\\|\\W\\|\\_>\\|[[:punct:]]\\)"
  "argh"
  :group 'helm-org-rifle :type 'regexp)

;; Then do:
(concat helm-org-rifle-re-begin-part token helm-org-rifle-re-end-part)
#+END_SRC

But it feels like it's matching slower now, so I guess I need to experiment with different ones...

#+NAME: symtest
#+BEGIN_SRC elisp :exports code
  (let ((target "(face-remap-set-base 'helm-selection")
        (tokens '("face" "helm" "blah" "selection" "base")))
    (cl-loop for token in tokens
             when (string-match (concat helm-org-rifle-re-begin-part token helm-org-rifle-re-end-part) target)
             collect token))
#+END_SRC

Let's try a simpler one:

#+BEGIN_SRC elisp :results none
(setq helm-org-rifle-re-begin-part
  "\\(\\B\\|\\_<\\|[[:punct:]]\\)")

(setq helm-org-rifle-re-end-part
  "\\(\\B\\|\\_>\\|[[:punct:]]\\)")
#+END_SRC

#+CALL: symtest[]()

#+RESULTS:
| face | helm | selection | base |

Ok, that works.  Now for another:

#+BEGIN_SRC elisp :results none
(setq helm-org-rifle-re-begin-part
  "\\(\\_<\\|[[:punct:]]\\)")

(setq helm-org-rifle-re-end-part
  "\\(\\_>\\|[[:punct:]]\\)")
#+END_SRC

#+CALL: symtest[]()

#+RESULTS:
| face | helm | selection | base |

Ok, that seems to work too.  Kind of makes sense: symbol boundaries or punctuation (which apparently doesn't count as a symbol-boundary...for some values of syntax table...)

Ok, this seems to work and seems to be decently fast.  Let's commit it and try it out for a while.

*** Target heading

Searching for just the first word should find this, but it doesn't; only searching for =face-remap-set-base= does.

#+BEGIN_SRC elisp
  :after-init-hook (lambda ()
                     (with-current-buffer helm-buffer
                       (face-remap-set-base 'helm-selection
                                            :underline 'unspecified
                                            :weight 'unspecified
                                            :background (face-attribute 'helm-selection :background))))
#+END_SRC

** DONE Order-sensitive matching

We want order to be irrelevant.  So searching for "bravo alpha" should match the following subheading...

And it does.  Except...

#+BEGIN_SRC elisp
;; This works
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "~/org/inbox.org") "emacs org-mode")

;; This works
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "~/org/inbox.org") "org-mode emac")

;; This gives a weird args-out-of-range error.  Does it only happen in this large file?
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "~/org/inbox.org") "org-mode emacs")
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "~/org/reference.org") "org-mode emacs")

;; No, it happens in the smaller file too...are hyphens the problem?...yes...
#+END_SRC



*** Test entry

alpha bravo

** DONE Hyphenated words cause order-sensitive matching?

#+BEGIN_SRC elisp
;; This works fine
(helm-org-rifle-get-candidates-in-buffer (current-buffer) "alpha charlie-delta")

;; So does this
(helm-org-rifle-get-candidates-in-buffer (current-buffer) "charlie-delta")

;; And this
(helm-org-rifle-get-candidates-in-buffer (current-buffer) "charlie-delta alpha")

;; But this does not!
(helm-org-rifle-get-candidates-in-buffer (current-buffer) "org-mode alpha")

;; But this works!
(helm-org-rifle-get-candidates-in-buffer (current-buffer) "org-mode blah")
#+END_SRC

The problem seems to be when the hyphenated word is on a different line than the non-hyphenated word (and we're only dealing with two words here...).  I sure don't know why.  Will have to step through the matching code...

*** ivy-regex-ignore-order

The =ivy-regex-ignore-order= setting in [[http://oremacs.com/swiper/#completion-styles][ivy/swiper]] might help with figuring this out.

*** Test entry

alpha bravo charlie-delta
argh org-mode blah

** DONE Priority

Headings with priorities should be correctly displayed in results.

*** [#B] Priority target heading

Baby elephant

** DONE Match and show tags
CLOSED: [2016-03-28 Mon 19:34]
:LOGBOOK:
- State "DONE"       from "UNDERWAY"   [2016-03-28 Mon 19:34]
- State "UNDERWAY"   from "DONE"       [2016-03-28 Mon 19:31]
- State "DONE"       from "TODO"       [2016-03-28 Mon 17:30]
:END:

This should show both this heading and the target:

#+BEGIN_SRC elisp :results value
(let ((helm-org-rifle-show-tags t))
        (helm-org-rifle-get-candidates-in-buffer (current-buffer) "charade"))
#+END_SRC

#+RESULTS:
| *** Target heading for tags test :charade:                                                            | 34684 |
| ** TODO Match and show tags buffer (current-buffer) "charade"))...buffer (current-buffer) "charade")) | 34242 |

This should show only this heading:

#+BEGIN_SRC elisp :results value
  (let ((helm-org-rifle-show-tags nil))
        (helm-org-rifle-get-candidates-in-buffer (current-buffer) "charade"))
#+END_SRC

#+RESULTS:
| ** TODO Match and show tags buffer (current-buffer) "charade"))...t heading for tags test :charade: ...buffer (current-buffer) "charade"))...buffer (current-buf...buffer (current-buffer) "charade")) | 34242 |

*** Target heading for tags test :charade: 

Yarr.

*** Target heading 2

This should also match for the content: :charade: 

*** Fontify tags correctly

Tags are being fontified just like the rest of the heading text, instead of like tags.

#+BEGIN_SRC elisp
  (helm-org-rifle-fontify-like-in-org-mode (s-join " " (list "*"
                                                             "Heading"
                                                             ":tag1:tag2:")))
#+END_SRC

#+RESULTS:
:  * Heading :tag1:tag2:

Seems like there needs to be whitespace after the tag string to make it appear in the =org-tag= face.

#+BEGIN_SRC elisp
  (helm-org-rifle-fontify-like-in-org-mode (s-join " " (list "*"
                                                             "Heading"
                                                             ":tag1:tag2: ")))
#+END_SRC

#+RESULTS:
: * Heading :tag1:tag2:

*** Match with colons

Surrounding tags with colons in the input doesn't seem to work:

#+BEGIN_SRC elisp :results value
(let ((helm-org-rifle-show-tags t))
        (helm-org-rifle-get-candidates-in-buffer (current-buffer) ":charade:"))
#+END_SRC

#+RESULTS:

It's because the colons in the tag string are being matched by the =:punct:= in the regexp's first part, eating the colon so it doesn't match the one in the input string.  I'm not sure how to fix that.  I guess I could make the matching regexp a series of =prefix-input-suffix= groups, and adjust the prefix and suffix for inputs that should match tags...seems messy but I guess it would work.

#+BEGIN_SRC txt
\(\_<\|[[:punct:]]\)\( \)\(\_>\|[[:punct:]]\)

"(_<|[[:punct:]])(:tag1:)(_>|[[:punct:]])"
#+END_SRC

#+BEGIN_SRC elisp
(string-match "^:[[:word:]@:]+:$" ":charade:tag2:")
(string-match "a" "ba")
#+END_SRC

#+BEGIN_SRC elisp
  (let* ((input (split-string input " " t))
         ;; Double colons in tag strings in input so they can match
         (input (mapcar (lambda (s)
                          (if (string-match helm-org-rifle-tags-re s)
                              (replace-regexp-in-string ":" "::" s)
                            s))
                        input))
         (match-all-tokens-re (mapconcat (lambda (token)
                                           (if (string-match helm-org-rifle-tags-re token)
                                               ;; Remove punct class from prefix and suffix so it can match tag strings
                                               (concat "\\_<" (regexp-quote token) "\\_>")
                                             ;; Not a tag; use normal prefix/suffix
                                             (concat helm-org-rifle-re-begin-part
                                                     (regexp-quote token)
                                                     helm-org-rifle-re-end-part)))))
         ;; TODO: Turn off case folding if input contains mixed case
         (case-fold-search t)
         results))
#+END_SRC

*** Match headings with multiple tags

Now it matches headings with one tag, but not more than one.

#+BEGIN_SRC elisp :results value
(let ((helm-org-rifle-show-tags t))
        (helm-org-rifle-get-candidates-in-buffer (current-buffer) ":gunn:"))
#+END_SRC

Maybe this will help, from =org.el=

#+BEGIN_SRC elisp
(org-re "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?")
#+END_SRC

#+BEGIN_SRC elisp :results list
  (let ((helm-org-rifle-show-tags t)
        (helm-org-rifle-tags-re (org-re "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?")))
    (--map (substring-no-properties (car it))  (helm-org-rifle-get-candidates-in-buffer (current-buffer) ":gunn:")))
#+END_SRC

Yeah, using that regexp from =org-complex-heading-regexp-format= in =org.el= seems to work.  Whew.

But this is the more correct one I think:

[[file:~/tmp/src/org-mode/lisp/org.el::(let%20((tag-re%20(concat%20org-outline-regexp-bol][re in org.el]]:

#+BEGIN_SRC elisp
  (let ((tag-re (concat org-outline-regexp-bol
                        "\\(?:.*?[ \t]\\)?"
                        (org-re ":\\([[:alnum:]_@#%:]+\\):[ \t]*$")))
        (targets (list ":yes:" "no")))
    (mapcar (it (when (string-match tag-re it)
                  (match-string 0 it))) targets))
#+END_SRC

#+RESULTS:
| :yes: | nil |

And this more minimal one seems to work too:

#+BEGIN_SRC elisp
  (let ((tag-re (org-re ":\\([[:alnum:]_@#%:]+\\):[ \t]*$"))
        (targets (list ":yes:" "location" ":tag:" "notatag")))
    (mapcar (it (when (string-match tag-re it)
                  (match-string 0 it))) targets))
#+END_SRC

#+RESULTS:
| :yes: | nil | :tag: | nil |

#+BEGIN_SRC elisp
  (let ((tag-re helm-org-rifle-tags-re)
        (targets (list ":yes:" "location" ":tag:" "notatag" ":website:Emacs:")))
    (mapcar (it (when (string-match tag-re it)
                  (match-string 0 it))) targets))
#+END_SRC

#+RESULTS:
| :yes: | nil | :tag: | nil |

**** Target heading with multiple tags :gunn:moon:

**** Trying to fix it again

[2016-04-01 Fri 21:18]  Here I go again...   This code is from up above, the first time I implemented/fixed tag matching:

#+BEGIN_SRC elisp :results list value
  (let ((helm-org-rifle-show-tags t)
        (helm-org-rifle-tags-re (org-re "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?")))
    (--map (substring-no-properties (car it))
           (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org")
                                                    ":website: Emacs")))
#+END_SRC

Ok, it seems to work now.

*Note:* Having this block of code (which I copied from further up) saved me probably hours of debugging.  Somehow in the course of fixing the context-matching and re-fixing negation, I broke tag matching, and the key to fixing it again was having this:

#+BEGIN_SRC elisp
(org-re "\\(?:[ \t]+\\(:[[:alnum:]_@#%%:]+:\\)\\)?")
#+END_SRC

...as opposed to this, which doesn't seem to work:

#+BEGIN_SRC elisp
(org-re ":\\([[:alnum:]_@#%:]+\\):[ \t]*$")
#+END_SRC

If I hadn't kept these notes, I'd probably have spent at least another hour tracing the problem to the regexp and going back into =org.el= and finding the right one again.  I've never kept notes like this about a programming project before, but I am completely sold on doing this now, especially with Org, which is *so powerful* with its inline evaluation, code block evaluation, intermingling of code with results with comments...

** DONE Negation
CLOSED: [2016-03-28 Mon 20:49]
:LOGBOOK:
- State "DONE"       from "UNDERWAY"   [2016-03-28 Mon 20:49]
- State "UNDERWAY"   from "DONE"       [2016-03-28 Mon 18:57]
- State "DONE"       from "UNDERWAY"   [2016-03-28 Mon 18:03]
- State "UNDERWAY"   from ""           [2016-03-28 Mon 17:30]
:END:

Emacs regexps don't support negation or lookahead, so we'll have to do it in stages.

1. Find negation patterns and move them to a separate list.
2. Test each match against negations and remove any that match.

*** Find negation patterns

#+BEGIN_SRC elisp
(mapcar (it (helm-org-rifle-prep-token it)) '("notatag" ":tag:"))

#+END_SRC

#+RESULTS:
| \(\(?:[ \n]+\(:[[:alnum:]_@#%%:]+:\)\)?\ | \)notatag\(\(?:[ \n]+\(:[[:alnum:]_@#%%:]+:\)\)?\ | \ | $\) | \(\(?:[ \n]+\(:[[:alnum:]_@#%%:]+:\)\)?\ | \):tag:\(\(?:[ \n]+\(:[[:alnum:]_@#%%:]+:\)\)?\ | \ | $\) |

#+BEGIN_SRC elisp
  (mapit '("notatag" ":tag:") (string-match helm-org-rifle-tags-re it))
#+END_SRC

#+RESULTS:
| 0 | 0 |

#+BEGIN_SRC elisp
  (let ((helm-org-rifle-tags-re (org-re ":\\([[:alnum:]_@#%:]+\\):[ \t]*$")))
    (mapit '("notatag" ":tag:") (string-match helm-org-rifle-tags-re it)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC elisp :results list
  (let* ((input (split-string "summertime !difficult easy" " " t))
         (negations (delq nil (mapcar (lambda (token)
                                        (when (string-match "^!" token)
                                          (setq input (remove token input))
                                          (helm-org-rifle-prep-token (s-chop-prefix "!" token))))
                                      input))))
    (list input negations))
#+END_SRC

#+RESULTS:
- ("summertime" "easy")
- ("\\(\\_<\\|[[:punct:]]\\)difficult\\(\\_>\\|[[:punct:]]\\)")

*** Test negation

#+BEGIN_SRC elisp
(let ((helm-org-rifle-show-tags t))
        (helm-org-rifle-get-candidates-in-buffer (current-buffer) "target !winter"))
#+END_SRC

*** Target positive: summertime easy


*** Target negative: summertime difficult

*** Avoid partial negation

e.g. searching for =location !cat= should not exclude results containing =location=.

This should return the =Target positive: location= heading:

#+BEGIN_SRC elisp :results list
  (let ((helm-org-rifle-show-tags t))
    (mapit (helm-org-rifle-get-candidates-in-buffer (current-buffer) "location !ca ")
           (s-replace "\n" "" (s-collapse-whitespace (org-no-properties (car it))))))
#+END_SRC

#+RESULTS:
- **** Target positive: location 
- *** Match headings with multiple tags (targets (list ":yes:" "location" ":tag:" "notatag")))

This should not return that heading:

#+BEGIN_SRC elisp :results list
  (let ((helm-org-rifle-show-tags t))
    (mapit (helm-org-rifle-get-candidates-in-buffer (current-buffer) "location !cat ")
           (s-replace "\n" "" (s-collapse-whitespace (org-no-properties (car it))))))
#+END_SRC

#+RESULTS:
- **** Target positive: location 
- *** Match headings with multiple tags (targets (list ":yes:" "location" ":tag:" "notatag")))

#+BEGIN_SRC elisp
  (let ((pat "\\bcat\\b")
        (targets '("a cat sleeps" "a catastrophe" "what")))
    (mapit targets (when (string-match pat it)(match-string 0 it))))
#+END_SRC

#+RESULTS:
| cat | nil | nil |

...sigh.  Use =s-matches= not =s-contains=.  Duh.

#+BEGIN_SRC elisp
  (let ((pat "\\(\\_<\\|[[:punct:]]\\)cat\\(\\_>\\|[[:punct:]]\\)")
        (target "a cat sleeps"))
    (s-matches? pat target))
#+END_SRC

#+RESULTS:
: t

**** Conclusion

[2016-03-28 Mon 20:38] Well, I think it's working correctly now, but I'm not 100% sure.  Time will tell.  If it's not, hopefully I'll discover it or get some reports.

**** Target positive: location

notacatbutadog

**** Target negative: cat

**** Target negative 2

cat

*** Profile with/without negation

**** Without negation

#+BEGIN_SRC elisp :results value
  (profile-rifle 10 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       10          3.090195806   0.3090195806
org-heading-components                                        1870        0.3476501630  0.0001859091
s-matches?                                                    12070       0.2892685670  2.396...e-05
helm-org-rifle-fontify-like-in-org-mode                       190         0.2818512350  0.0014834275
line-beginning-position                                       8850        0.2493933970  2.818...e-05
search-forward-regexp                                         6200        0.2002201670  3.229...e-05
org-do-latex-and-related                                      190         0.183021584   0.0009632714
string-match                                                  16180       0.1157849300  7.156...e-06
goto-char                                                     8080        0.1073119259  1.328...e-05
org-back-to-heading                                           1870        0.0820826830  4.389...e-05
outline-back-to-heading                                       1870        0.0757641679  4.051...e-05
outline-next-heading                                          1880        0.07128534    3.791...e-05
line-end-position                                             4330        0.0655929360  1.514...e-05
outline-previous-heading                                      1870        0.0335165519  1.792...e-05
org-at-heading-p                                              4330        0.0254124080  5.868...e-06
buffer-substring-no-properties                                8340        0.0160720620  1.927...e-06
outline-on-heading-p                                          6200        0.0159791459  2.577...e-06
mapcar                                                        2098        0.0149361860  7.119...e-06
s-trim                                                        1010        0.0134555670  1.332...e-05
s-join                                                        2450        0.0121108709  4.943...e-06
#+end_example



**** With negation
:PROPERTIES:
:ID:       413c432f-6c8a-4f41-bbd4-486d859fe571
:END:

#+BEGIN_SRC elisp :results value
  (profile-rifle 10 (helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm !mail"))
#+END_SRC

#+RESULTS:
#+begin_example txt
helm-org-rifle-get-candidates-in-buffer                       10          3.091637074   0.3091637074
org-heading-components                                        1670        0.4687531710  0.0002806905
buffer-substring-no-properties                                7070        0.2041990190  2.888...e-05
goto-char                                                     6800        0.1843262129  2.710...e-05
map                                                           1680        0.1841657830  0.0001096224
org-back-to-heading                                           1670        0.1832357559  0.0001097220
mapcar                                                        1728        0.1819894680  0.0001053179
car                                                           17102       0.1810326969  1.058...e-05
s-join                                                        1790        0.1791070739  0.0001000598
outline-back-to-heading                                       1670        0.1777289460  0.0001064245
mapconcat                                                     1820        0.1752004220  9.626...e-05
search-forward-regexp                                         3470        0.1643956769  4.737...e-05
outline-next-heading                                          1670        0.1309705520  7.842...e-05
line-beginning-position                                       5300        0.1271316750  2.398...e-05
line-end-position                                             3460        0.117448273   3.394...e-05
outline-previous-heading                                      1670        0.0792564969  4.745...e-05
s-contains?                                                   6740        0.0599737680  8.898...e-06
helm-org-rifle-prep-token                                     3490        0.0288021979  8.252...e-06
helm-org-rifle-fontify-like-in-org-mode                       40          0.0239840029  0.0005996000
string-match                                                  12220       0.0191793460  1.569...e-06
#+end_example

*** DONE Avoid clearing results when bare "!" is entered

It seems awkward that all of the results disappear when a bare =!= is entered.  Even if you type quickly, they all disappear and then reappear.  Should be possible to fix this...

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm !")
(helm-org-rifle-get-candidates-in-buffer (find-file-noselect "~/org/inbox.org") "emacs helm !org")
#+END_SRC

Fixed.  Thanks to [[https://www.reddit.com/user/washy99999][/u/washy9999]] for the feedback!

* Plans

** TODO Match tags separately

This would probably make it simpler and faster.  Rather than trying to match a tags token across the entire node, it could just be matched against the tags string.  Could probably do away with the complex and confusing tags regexp matching and simplify the prep-token function.

** TODO Substring matching

Does searching for "solution" match this subheading?

#+BEGIN_SRC elisp
(helm-org-rifle-get-candidates-in-buffer (get-file-buffer "test.org") "solution")
#+END_SRC

...No, it does not.  That will probably need to be an option, customizable and/or with a prefix arg.

*** Test entry

Solutions

*** TODO [#A] Weird heading-only, second-word substring matching

[[https://www.reddit.com/r/emacs/comments/4c4fpo/helmorgrifle_rifle_through_your_org_files/d1hdoop][From /u/washy9999]]:

#+BEGIN_QUOTE
incidentally, on the matter of searching for substrings... if i enter a single word to search for i get a results list. if i then start entering a second word helm filters the results for each character that i enter. so, i get substring searches for words after the first! (this is for headings...it gets more complicated if i do searches that return topic content.)
#+END_QUOTE

Hm, this is strange.  I'll have to check on it.

** DONE Support new Helm with input-idle-delay

Thanks to [[https://github.com/emacs-helm/helm/issues/1454#issuecomment-204519216][Thierry's help]], this should help prevent flickering.  This will be available in Helm 1.9.4 or commits after [2016-04-01 Fri].

** MAYBE Match only headings

It might be nice to only match against headings, but this is not as easy as it might seem.  This whole package is made to search both headings and content.

** MAYBE Testing with [[https://github.com/jorgenschaefer/emacs-buttercup][Buttercup]]

Could be good for testing e.g. negation, to make sure I don't break it.

